import dotenv from 'dotenv';
import 'dotenv/config';
import { Telegraf } from 'telegraf';
import { cleanMultipleTexts } from '../src/utils/groqCleaner.js';
import { generateWordDoc } from '../src/utils/wordGenerator.js';
import { createClient } from '@supabase/supabase-js';
import { generatePdfFromHtml } from '../src/utils/htmlToPdf.js';
import { createEngineeringReportHTML } from '../src/templates/engineeringReportHTML.js';
import { createProfessionalReportHTML } from '../src/templates/professionalReport.js';
import { createProfessionalWordReport } from '../src/templates/professionalWordReport.js';
import { Packer } from 'docx';
import { cleanFieldText } from '../src/agents/dataCleanerAgent.js';  // ‚Üê ADD AI AGENTS
import { categorizePhoto } from '../src/agents/photoOrganizerAgent.js';  // ‚Üê ADD AI AGENTS
import { generateReportPDF } from '../src/agents/reportGeneratorAgent.js';  // ‚Üê ADD AI AGENTS
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Fix __dirname for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

dotenv.config();

const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN as string;
if (!BOT_TOKEN) throw new Error('Missing TELEGRAM_BOT_TOKEN');

const bot = new Telegraf(BOT_TOKEN);

interface UserSession {
  notes: string[];
  photoUrls: string[];
  photoBuffers: Buffer[];
  photoCaptions: string[];  // ‚Üê Store caption for each photo
  photoCategories: string[];  // ‚Üê NEW: Store AI-categorized photo types
}


const sessions = new Map<number, UserSession>();

// ============================================
// COMMAND HANDLERS (Must come BEFORE text handler)
// ============================================

// START COMMAND - Initialize without clearing existing data
bot.start((ctx) => {
  const userId = ctx.from.id;
  console.log(`‚úÖ User started: ${ctx.from.first_name}`);
  
  // Only create new session if one doesn't exist
    if (!sessions.has(userId)) {
    sessions.set(userId, { notes: [], photoUrls: [], photoBuffers: [], photoCaptions: [], photoCategories: [] });
  }
  
  const session = sessions.get(userId)!;
  
  ctx.reply(
    'üëã Welcome to Field Report Bot!\n\n' +
    'Send me:\n' +
    'üìù Text notes about your field work\n' +
    'üì∑ Photos to document your inspection\n\n' +
    'üìÑ Commands:\n' +
    '/exportword - Generate Word + PDF (AI-cleaned) üÜï\n' +
    '/clear - Clear current session\n' +
    '/help - Show all commands\n\n' +
    `üìä Current session: ${session.notes.length} note(s), ${session.photoBuffers.length} photo(s)\n\n` +
    'ü§ñ Powered by GROQ AI text cleaning'
  );
});

// HELP COMMAND
bot.help((ctx) => {
  console.log(`üìã Help requested by ${ctx.from.first_name}`);
  ctx.reply(
    'üìã Available Commands:\n\n' +
    '/start - Start bot & show current session\n' +
    '/exportword - Generate Word + PDF (AI-cleaned) üÜï\n' +
    '/clear - Clear session data\n' +
    '/help - Show this message\n\n' +
    'üí° Tip: Send multiple notes and photos before generating reports!\n' +
    'ü§ñ AI text cleaning powered by GROQ'
  );
});

// CLEAR COMMAND - Reset session
bot.command('clear', async (ctx) => {
  const userId = ctx.from.id;
  sessions.delete(userId);
  console.log(`üóëÔ∏è Session cleared for ${ctx.from.first_name}`);
  
  await ctx.reply(
    'üóëÔ∏è Session cleared!\n\n' +
    'Start fresh by sending new notes and photos.'
  );
});

// EXPORTWORD COMMAND - Generate Word + PDF with AI cleaning
bot.command('exportword', async (ctx) => {
  try {
    const userId = ctx.from.id;
    const session = sessions.get(userId);

    console.log(`üìù Word export requested by ${ctx.from.first_name}`);

    if (!session || (session.notes.length === 0 && session.photoBuffers.length === 0)) {
      await ctx.reply('‚ùå No data yet.\n\nSend notes and photos, then type /exportword');
      return;
    }

    await ctx.reply('üìù Generating Word + PDF with AI cleaning... (15-25 seconds)');

    // Clean with GROQ AI
    const cleanedNotes = await cleanMultipleTexts(session.notes);
    console.log(`‚úÖ Cleaned ${cleanedNotes.length} notes`);

    // Save photos temporarily
    const tempPhotoPaths: string[] = [];
    const tempDir = path.join(__dirname, '../temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    for (let i = 0; i < session.photoBuffers.length; i++) {
      const tempPath = path.join(tempDir, `photo-${userId}-${i}.jpg`);
      fs.writeFileSync(tempPath, session.photoBuffers[i]);
      tempPhotoPaths.push(tempPath);
    }

        // Prepare report data for professional templates
    const reportData = {
      client: 'Field Inspection',
      site: 'Site Location', 
      technician: ctx.from?.username || ctx.from?.first_name || 'Field Technician',
      notes: cleanedNotes,
      photoUrls: session.photoUrls,
      photoCaptions: session.photoCaptions,
      photoBuffers: session.photoBuffers
    };

    // Generate Professional PDF
    await ctx.telegram.sendMessage(ctx.chat.id, 'üìÑ Generating professional PDF report...');
    const html = createProfessionalReportHTML(reportData);
    const pdfFilename = `professional-report-${userId}-${Date.now()}.pdf`;
    const pdfPath = path.join(tempDir, pdfFilename);
    
    await generatePdfFromHtml({
      html: html,
      outputPath: pdfPath
    });

    // Generate Professional Word document
    await ctx.telegram.sendMessage(ctx.chat.id, 'üìÑ Generating professional Word report...');
    const doc = createProfessionalWordReport(reportData);
    const wordBuffer = await Packer.toBuffer(doc);
    const wordFilename = `professional-report-${userId}-${Date.now()}.docx`;

    console.log(`‚úÖ PDF saved: ${pdfPath}`);

        // Upload PDF to Supabase
    const pdfBuffer = fs.readFileSync(pdfPath);
    const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_ANON_KEY!);
    const { data: pdfData, error: pdfError } = await supabase
      .storage
      .from('reports')
      .upload(pdfFilename, pdfBuffer, {
        contentType: 'application/pdf'
      });
    
    if (pdfError) throw pdfError;
    
    const { data: pdfUrlData } = supabase
      .storage
      .from('reports')
      .getPublicUrl(pdfFilename);

    // Upload Word to Supabase
    const { data: wordData, error: wordError } = await supabase
      .storage
      .from('reports')
      .upload(wordFilename, wordBuffer, {
        contentType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      });
    
    if (wordError) throw wordError;
    
    const { data: wordUrlData } = supabase
      .storage
      .from('reports')
      .getPublicUrl(wordFilename);

    // Send both files to user
    await ctx.replyWithDocument({ source: wordBuffer, filename: wordFilename });
    await ctx.replyWithDocument({ 
      source: pdfBuffer, 
      filename: pdfFilename 
    }, {
      caption: '‚úÖ Professional Reports Generated\n\nüìù Clean professional format\nüì∑ Photos organized by sections\nüìÑ No border frames (better compatibility)\n\nType /exportword again or /clear to reset.'
    });

    // Clean up temp files
    tempPhotoPaths.forEach(p => {
      try {
        fs.unlinkSync(p);
      } catch(e) {}
    });
    fs.unlinkSync(pdfPath);

  } catch (error) {
    console.error('‚ùå Export error:', error);
    await ctx.reply('‚ùå Error: ' + (error as Error).message);
  }
});

// ============================================
// MESSAGE HANDLERS (Must come AFTER commands)
// ============================================

// Handle regular text messages (field notes)
// ‚ö†Ô∏è ONLY ONE text handler - no duplicates!
bot.on('text', async (ctx) => {
  const text = ctx.message.text;
  
  // Ignore ALL commands - let command handlers deal with them
  if (text.startsWith('/')) {
    return;
  }
  
  const userId = ctx.from.id;
  const userName = ctx.from.first_name || 'User';
  
  console.log(`üìù Text from ${userName}: ${text}`);
  
  // Initialize session if it doesn't exist
  if (!sessions.has(userId)) {
        sessions.set(userId, { 
          notes: [], 
    photoUrls: [], 
    photoBuffers: [], 
    photoCaptions: [], 
    photoCategories: []  // ‚Üê ADD THIS
    });
    console.log(`üÜï New session created for ${userName}`);
  }
  
  // Get the user's session
  const session = sessions.get(userId)!;
  
  // Add the note to session
  session.notes.push(text);
  console.log(`‚úÖ Note added. Total notes: ${session.notes.length}`);
  
  // Send confirmation with current count
  await ctx.reply(
    `‚úÖ Note ${session.notes.length} saved!\n\n` +
    `üìä Current session:\n` +
    `‚Ä¢ ${session.notes.length} note(s)\n` +
    `‚Ä¢ ${session.photoBuffers.length} photo(s)\n\n` +
    `Type /exportword when ready to generate Word + PDF.`
  );
});

// PHOTO HANDLER - Download and store photos WITH CAPTIONS
bot.on('photo', async (ctx) => {
  try {
    const userId = ctx.from.id;
    const userName = ctx.from.first_name || 'User';
    
    // Get caption if user added one
    const caption = ctx.message.caption || '';
    
    console.log(`üì∑ Photo from ${userName}${caption ? ` with caption: "${caption}"` : ''}`);
    
      if (!sessions.has(userId)) {
    sessions.set(userId, { notes: [], photoUrls: [], photoBuffers: [], photoCaptions: [], photoCategories: [] });
  }
    
    const session = sessions.get(userId)!;
    
    // Get highest resolution photo
    const photo = ctx.message.photo[ctx.message.photo.length - 1];
    const fileId = photo.file_id;
    
    // Download photo from Telegram
    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await fetch(fileLink.href);
    const photoBuffer = Buffer.from(await response.arrayBuffer());
    
        // Store photo AND its caption with AI categorization
    session.photoUrls.push(fileLink.href);
    session.photoBuffers.push(photoBuffer);
    session.photoCaptions.push(caption);  // ‚Üê STORE THE CAPTION
    const category = categorizePhoto(caption);  // ‚Üê AI CATEGORIZATION
    session.photoCategories.push(category);  // ‚Üê STORE CATEGORY
    
    console.log(`üíæ Photo ${session.photoBuffers.length} saved (${(photoBuffer.length / 1024).toFixed(1)}KB)`);
    if (caption) {
      console.log(`üìù Caption: "${caption}"`);
    }
    
        await ctx.reply(
      `üì∑ Photo ${session.photoBuffers.length} saved!${caption ? `\nüìù Caption: "${caption}"` : ''}${category !== 'uncategorized' ? `\nüè∑Ô∏è Category: ${category}` : ''}\n\n` +
      `üìä Current session:\n` +
      `‚Ä¢ ${session.notes.length} note(s)\n` +
      `‚Ä¢ ${session.photoBuffers.length} photo(s)\n\n` +
      `Type /exportword when ready to generate Word + PDF.`
    );
    
  } catch (error) {
    console.error('‚ùå Photo processing error:', error);
    await ctx.reply('‚ùå Error saving photo. Please try again.');
  }
});


// ============================================
// START BOT
// ============================================

bot.launch();
console.log('‚úÖ Bot is running with polling mode!');
console.log('üì° Listening for messages...');
console.log('üìÑ PDF generation enabled!');

// GRACEFUL SHUTDOWN
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));
